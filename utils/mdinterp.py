"""
Generate interpolate code.

TODO: Intel compiler can generate fast bytecode with good auto-vectorization,
while gcc/clang can't.
"""
import sympy as sypy
from sympy.codegen import ast
import symengine as sy
import re

def get_names(idx, dim=3):
    names = ['dx', 'dy', 'dz']
    return ' '.join([n + '[%d]'%idx for n in names[:dim]])

def gen_diffs(idx):
    dx, dy, dz = sy.symbols(get_names(idx))
    d0 = [1]
    d1 = [dx, dy, dz]
    d2 = [dx*dx, dy*dy, dz*dz, dx*dy, dx*dz, dy*dz]
    d3 = [dx**3, dy**3, dz**3,
          dx**2*dy, dx**2*dz, dy**2*dx, dy**2*dz, dz**2*dx, dz**2*dy,
          dx*dy*dz]
    return d0, d1, d2, d3

def gen_diffs_2(idx):
    dx, dy = sy.symbols(get_names(idx, dim=2))
    d0 = [1]
    d1 = [dx, dy]
    d2 = [dx**2, dy**2, dx*dy]
    d3 = [dx**3, dy**3, dx**2*dy, dx*dy**2]
    return d0, d1, d2, d3

def get_point_matrix(num_points, order=3, dim=3):
    rows = []
    fs = []
    for i in range(num_points):
        if dim == 3:
            ds = gen_diffs(i)
        elif dim == 2:
            ds = gen_diffs_2(i)
        d = []
        for o in range(order+1):
            d.extend(ds[o])
        rows.append(d)

        f = []
        for j in range(dim):
            f.append(sy.Symbol('f[%d][%d]'%(i, j)))
        fs.append(f)
    return sy.Matrix(rows), sy.Matrix(fs)

def solve(num_points, order=3, dim=3):
    mat, val = get_point_matrix(num_points, order, dim=dim)
    if mat.shape[0] == mat.shape[1]:
        print('Square mat')
        mat1 = mat
        val1 = val
    else:
        print(mat.shape)
        mat1 = mat.T @ mat
        val1 = mat.T @ val
    mat1_inv = mat1.inv()
    result = mat1_inv @ val1
    f = result[0, :]
    f = sy.cse(f)
    '''
    for exp in f[0]:
        print(exp)
    for _f in f[1]:
        print(_f)
    '''
    return f

def pow_repl(m):
    order = m.group(2)
    base = m.group(1)
    forder = float(order)
    order = int(order)
    if forder != order:
        return m.group(0)

    base = f'({base})'
    code = '*'.join([base]*order)
    return f'({code})'

def gen_code(num_points, order, dim, fn_name=None, dtype='Real'):
    if fn_name is None:
        fn_name = f'interp_{num_points}_{order}_{dim}'
    input_coords = ['dx', 'dy', 'dz'][:dim]
    input_coords_type = f'std::array<{dtype}, {num_points}>'
    coords_declare = [input_coords_type + ' ' + c for c in input_coords]
    target_declare = f'std::array<std::array<{dtype}, 3>, {num_points}> f'
    params = ', '.join(coords_declare + [target_declare])

    if dtype == 'Real':
        declare = f'template<typename {dtype}>\nstd::array<{dtype}, 3> {fn_name}({params}) {{'
    else:
        assert(dtype in ['double', 'float'])
        declare = f'std::array<{dtype}, 3> {fn_name}({params}) {{'

    result = solve(num_points, order, dim)

    lines = []
    return_declare = f'std::array<{dtype}, 3> result;'
    lines.append(return_declare)

    pow_pattern = re.compile(r'std::pow\((.*?),\s*(.*?)\)')

    for tar, expr in result[0]:
        line = f'{dtype} ' + sypy.cxxcode(ast.Assignment(tar, expr))
        lines.append(pow_pattern.sub(pow_repl, line))

    for i, expr in enumerate(result[1]):
        line = f'result[{i}] = ' + sypy.cxxcode(expr) + ';'
        lines.append(pow_pattern.sub(pow_repl, line))

    lines.append('return result;')

    code = declare + '\n    ' + '\n    '.join(lines) + '\n}'

    return code

items = [
    #(4, 1, 3),
    (10, 2, 3),
    #(20, 3, 3),

    #(3, 1, 2),
    (6, 2, 2),
    #(10, 3, 2)
]

dtype = 'Real'
codes = []
for item in items:
    codes.append(gen_code(*item, dtype=dtype))

ext = 'hpp' if dtype == 'Real' else 'cpp'
with open(f'interp_poly.{ext}', 'w') as f:
    f.write('// Generated by utils/mdinterp.py\n')
    f.write('#include <array>\n')
    f.write('\n'.join(codes))
